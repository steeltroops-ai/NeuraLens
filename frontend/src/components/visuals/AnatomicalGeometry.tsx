/**
 * Anatomical Geometry Visuals for Neuralens
 *
 * Advanced anatomical visualizations with accurate geometry and Apple-inspired design.
 * Features:
 * - Eye: cornea refraction, iris fibers with fractal noise, reactive pupil, retinal vessels
 * - Brain: hemisphere outline + gyri generated by Perlin noise displacement
 * - Speech: vocal tract cross-section + formant-based waveform visualizer
 * - Hand: finger kinematics using forward kinematics (MCP, PIP, DIP joints)
 *
 * Design Philosophy: Clean white backgrounds, muted accents, minimal UI, precise geometry
 */

'use client';

import React, { useEffect, useRef, useState } from 'react';

// Utilities for high-DPI canvas rendering
function useHiDpiCanvas() {
  const ref = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = ref.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d')!;

    const resize = () => {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const cw = Math.max(240, canvas.clientWidth);
      const ch = Math.max(160, canvas.clientHeight);
      canvas.width = Math.floor(cw * dpr);
      canvas.height = Math.floor(ch * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };

    resize();
    const ro = new ResizeObserver(resize);
    ro.observe(canvas);
    return () => ro.disconnect();
  }, []);

  return ref;
}

function clamp(v: number, a: number, b: number) {
  return Math.min(b, Math.max(a, v));
}

// Simple Perlin noise implementation for organic shapes
function makePerlin() {
  const perm = new Uint8Array(512);
  const p = new Uint8Array(256);

  for (let i = 0; i < 256; i++) p[i] = i;

  // Shuffle array
  for (let i = 255; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const t = p[i]!;
    p[i] = p[j]!;
    p[j] = t;
  }

  for (let i = 0; i < 512; i++) perm[i] = p[i & 255]!;

  function fade(t: number) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }
  function lerp(a: number, b: number, t: number) {
    return a + t * (b - a);
  }
  function grad(hash: number, x: number, y: number) {
    const h = hash & 3;
    const u = h < 2 ? x : y;
    const v = h < 2 ? y : x;
    return (h & 1 ? -u : u) + (h & 2 ? -2 * v : 2 * v);
  }

  return function noise(x: number, y: number) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    const xf = x - Math.floor(x);
    const yf = y - Math.floor(y);

    const topRight = perm[perm[X + 1]! + Y + 1]!;
    const topLeft = perm[perm[X]! + Y + 1]!;
    const bottomRight = perm[perm[X + 1]! + Y]!;
    const bottomLeft = perm[perm[X]! + Y]!;

    const u = fade(xf);
    const v = fade(yf);

    const x1 = lerp(grad(bottomLeft, xf, yf), grad(bottomRight, xf - 1, yf), u);
    const x2 = lerp(
      grad(topLeft, xf, yf - 1),
      grad(topRight, xf - 1, yf - 1),
      u
    );

    return lerp(x1, x2, v);
  };
}

// Eye Anatomy Visualization
export const EyeAnatomy: React.FC<{ className?: string }> = ({
  className = '',
}) => {
  const canvasRef = useHiDpiCanvas();
  const [pupilSize, setPupilSize] = useState(0.3);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d')!;
    const noise = makePerlin();

    const animate = () => {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      const cx = w / 2;
      const cy = h / 2;
      const radius = Math.min(w, h) * 0.35;

      // Clear canvas
      ctx.clearRect(0, 0, w, h);

      // Draw sclera (white of eye)
      ctx.fillStyle = '#f8fafc';
      ctx.beginPath();
      ctx.ellipse(cx, cy, radius, radius * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Draw iris with fractal patterns
      const irisRadius = radius * 0.6;
      const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, irisRadius);
      gradient.addColorStop(0, '#0d9488');
      gradient.addColorStop(0.3, '#0f766e');
      gradient.addColorStop(0.7, '#134e4a');
      gradient.addColorStop(1, '#042f2e');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(cx, cy, irisRadius, 0, Math.PI * 2);
      ctx.fill();

      // Draw iris fibers using noise
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 0.5;

      for (let i = 0; i < 60; i++) {
        const angle = (i / 60) * Math.PI * 2;
        const startX = cx + Math.cos(angle) * (irisRadius * 0.3);
        const startY = cy + Math.sin(angle) * (irisRadius * 0.3);

        ctx.beginPath();
        ctx.moveTo(startX, startY);

        for (let r = 0.3; r < 1; r += 0.1) {
          const noiseVal = noise(angle * 3, r * 5) * 0.1;
          const x = cx + Math.cos(angle + noiseVal) * (irisRadius * r);
          const y = cy + Math.sin(angle + noiseVal) * (irisRadius * r);
          ctx.lineTo(x, y);
        }
        ctx.stroke();
      }

      // Draw reactive pupil
      const pupilRadius = irisRadius * pupilSize;
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(cx, cy, pupilRadius, 0, Math.PI * 2);
      ctx.fill();

      // Draw retinal blood vessels
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 1;

      const vessels = [
        { angle: 0.2, length: 0.8 },
        { angle: 1.8, length: 0.7 },
        { angle: 3.5, length: 0.9 },
        { angle: 4.8, length: 0.6 },
      ];

      vessels.forEach((vessel) => {
        ctx.beginPath();
        ctx.moveTo(cx, cy);

        for (let t = 0; t < vessel.length; t += 0.1) {
          const noiseOffset = noise(vessel.angle * 2, t * 3) * 0.2;
          const x = cx + Math.cos(vessel.angle + noiseOffset) * (radius * t);
          const y = cy + Math.sin(vessel.angle + noiseOffset) * (radius * t);
          ctx.lineTo(x, y);
        }
        ctx.stroke();
      });

      // Animate pupil dilation
      setPupilSize((prev) => {
        const target = 0.25 + Math.sin(Date.now() * 0.001) * 0.1;
        return prev + (target - prev) * 0.05;
      });

      requestAnimationFrame(animate);
    };

    animate();
  }, []);

  return (
    <canvas
      ref={canvasRef}
      className={`h-48 w-full rounded-xl bg-gradient-to-br from-slate-50 to-slate-100 ${className}`}
      style={{ imageRendering: 'auto' }}
    />
  );
};

// Brain Hemisphere Visualization
export const BrainAnatomy: React.FC<{ className?: string }> = ({
  className = '',
}) => {
  const canvasRef = useHiDpiCanvas();

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d')!;
    const noise = makePerlin();

    const animate = () => {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      const cx = w / 2;
      const cy = h / 2;

      ctx.clearRect(0, 0, w, h);

      // Draw brain hemispheres
      const hemisphereWidth = w * 0.35;
      const hemisphereHeight = h * 0.6;

      // Left hemisphere
      ctx.fillStyle = '#e2e8f0';
      ctx.beginPath();
      ctx.ellipse(
        cx - hemisphereWidth * 0.3,
        cy,
        hemisphereWidth,
        hemisphereHeight,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Right hemisphere
      ctx.beginPath();
      ctx.ellipse(
        cx + hemisphereWidth * 0.3,
        cy,
        hemisphereWidth,
        hemisphereHeight,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Draw gyri (brain folds) using Perlin noise
      ctx.strokeStyle = '#94a3b8';
      ctx.lineWidth = 1.5;

      for (let side = -1; side <= 1; side += 2) {
        const centerX = cx + side * hemisphereWidth * 0.3;

        for (let i = 0; i < 8; i++) {
          const baseY =
            cy - hemisphereHeight * 0.4 + (i / 7) * hemisphereHeight * 0.8;

          ctx.beginPath();
          for (
            let x = -hemisphereWidth * 0.8;
            x <= hemisphereWidth * 0.8;
            x += 5
          ) {
            const noiseVal =
              noise(x * 0.01, baseY * 0.01 + Date.now() * 0.0001) * 20;
            const y = baseY + noiseVal;

            if (x === -hemisphereWidth * 0.8) {
              ctx.moveTo(centerX + x, y);
            } else {
              ctx.lineTo(centerX + x, y);
            }
          }
          ctx.stroke();
        }
      }

      // Draw corpus callosum (connection between hemispheres)
      ctx.strokeStyle = '#1e293b';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx - hemisphereWidth * 0.2, cy);
      ctx.lineTo(cx + hemisphereWidth * 0.2, cy);
      ctx.stroke();

      requestAnimationFrame(animate);
    };

    animate();
  }, []);

  return (
    <canvas
      ref={canvasRef}
      className={`h-48 w-full rounded-xl bg-gradient-to-br from-slate-50 to-slate-100 ${className}`}
    />
  );
};

// Speech Waveform Visualization
export const SpeechWaveform: React.FC<{ className?: string }> = ({
  className = '',
}) => {
  const canvasRef = useHiDpiCanvas();

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d')!;

    const animate = () => {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      const time = Date.now() * 0.002;

      ctx.clearRect(0, 0, w, h);

      // Draw vocal tract outline
      ctx.strokeStyle = '#64748b';
      ctx.lineWidth = 2;
      ctx.beginPath();

      // Simplified vocal tract shape
      const tractPoints = [
        [w * 0.1, h * 0.8], // Glottis
        [w * 0.3, h * 0.6], // Pharynx
        [w * 0.5, h * 0.4], // Oral cavity
        [w * 0.7, h * 0.3], // Tongue position
        [w * 0.9, h * 0.2], // Lips
      ];

      tractPoints.forEach((point, i) => {
        if (i === 0) {
          ctx.moveTo(point[0]!, point[1]!);
        } else {
          ctx.lineTo(point[0]!, point[1]!);
        }
      });
      ctx.stroke();

      // Draw formant-based waveform
      ctx.strokeStyle = '#0d9488';
      ctx.lineWidth = 1.5;
      ctx.beginPath();

      for (let x = 0; x < w; x += 2) {
        // Simulate formant frequencies
        const f1 = Math.sin(x * 0.02 + time) * 0.3; // First formant
        const f2 = Math.sin(x * 0.05 + time * 1.5) * 0.2; // Second formant
        const f3 = Math.sin(x * 0.08 + time * 2) * 0.1; // Third formant

        const y = h * 0.5 + (f1 + f2 + f3) * h * 0.3;

        if (x === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();

      // Draw frequency spectrum
      ctx.fillStyle = 'rgba(13, 148, 136, 0.3)';
      for (let i = 0; i < 20; i++) {
        const x = (i / 19) * w;
        const freq = 100 + i * 200; // Frequency range
        const amplitude = Math.sin(time + i * 0.5) * 0.5 + 0.5;
        const barHeight = amplitude * h * 0.2;

        ctx.fillRect(x - 2, h - barHeight, 4, barHeight);
      }

      requestAnimationFrame(animate);
    };

    animate();
  }, []);

  return (
    <canvas
      ref={canvasRef}
      className={`h-48 w-full rounded-xl bg-gradient-to-br from-slate-50 to-slate-100 ${className}`}
    />
  );
};

// Hand Kinematics Visualization
export const HandKinematics: React.FC<{ className?: string }> = ({
  className = '',
}) => {
  const canvasRef = useHiDpiCanvas();

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d')!;

    const animate = () => {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      const time = Date.now() * 0.001;

      ctx.clearRect(0, 0, w, h);

      // Draw hand outline
      const palmCenter = [w * 0.5, h * 0.7];
      const palmRadius = Math.min(w, h) * 0.15;

      ctx.fillStyle = '#f1f5f9';
      ctx.strokeStyle = '#64748b';
      ctx.lineWidth = 2;

      // Draw palm
      ctx.beginPath();
      ctx.arc(palmCenter[0]!, palmCenter[1]!, palmRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Draw fingers with joint kinematics
      const fingers = [
        { angle: -0.6, length: [0.8, 0.7, 0.5] }, // Thumb
        { angle: -0.3, length: [1.0, 0.8, 0.6] }, // Index
        { angle: 0, length: [1.1, 0.9, 0.7] }, // Middle
        { angle: 0.3, length: [1.0, 0.8, 0.6] }, // Ring
        { angle: 0.6, length: [0.8, 0.6, 0.4] }, // Pinky
      ];

      fingers.forEach((finger, fingerIndex) => {
        let currentX = palmCenter[0]! + Math.cos(finger.angle) * palmRadius;
        let currentY = palmCenter[1]! + Math.sin(finger.angle) * palmRadius;

        let currentAngle = finger.angle;

        finger.length.forEach((segmentLength, segmentIndex) => {
          // Add joint movement
          const jointMovement =
            Math.sin(time + fingerIndex * 0.5 + segmentIndex) * 0.3;
          currentAngle += jointMovement;

          const segmentPixelLength = segmentLength * palmRadius;
          const nextX = currentX + Math.cos(currentAngle) * segmentPixelLength;
          const nextY = currentY + Math.sin(currentAngle) * segmentPixelLength;

          // Draw segment
          ctx.beginPath();
          ctx.moveTo(currentX, currentY);
          ctx.lineTo(nextX, nextY);
          ctx.stroke();

          // Draw joint
          ctx.beginPath();
          ctx.arc(currentX, currentY, 3, 0, Math.PI * 2);
          ctx.fillStyle = '#0d9488';
          ctx.fill();

          currentX = nextX;
          currentY = nextY;
        });

        // Draw fingertip
        ctx.beginPath();
        ctx.arc(currentX, currentY, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#dc2626';
        ctx.fill();
      });

      requestAnimationFrame(animate);
    };

    animate();
  }, []);

  return (
    <canvas
      ref={canvasRef}
      className={`h-48 w-full rounded-xl bg-gradient-to-br from-slate-50 to-slate-100 ${className}`}
    />
  );
};
